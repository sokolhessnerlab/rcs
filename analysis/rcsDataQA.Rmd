---
title: "RCS Data QA"
author: "Hayley Brooks"
date: "2022-10-12"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(readr)
library(lme4)

config = config::get()

```

```{r load-datafiles,echo=FALSE}
# for offline work
#rdmPath = "/Users/hayley/Desktop/RCS/data/rdmData"
#ospPath= "/Users/hayley/Desktop/RCS/data/ospanData"
#sspPath = "/Users/hayley/Desktop/RCS/data/symspanData"

# online work
rdmPath = file.path(config$path$data$rdmData)
sspPath = file.path(config$path$data$symspData)
ospPath = file.path(config$path$data$ospData)

rdmFiles = list.files(rdmPath, pattern = "rcsRDM_sub")
sspFiles = list.files(sspPath, pattern = "rcsSYMSPANbothReal_")
ospFiles = list.files(ospPath, pattern = "rcsOSPANbothReal_")
rdmPostQFiles = list.files(rdmPath, pattern = "rcsPostQ_sub")
rdmOutcomeFiles = list.files(rdmPath, pattern ="rcsTrialOutcome_sub")
```

```{r combine-rdm-files, include=FALSE, results=FALSE}
rdmDF1 <- file.path(rdmPath,rdmFiles[1:99]) %>% 
  lapply(read_csv) %>% 
  bind_rows

rdmDF2 <- file.path(rdmPath,rdmFiles[100:length(rdmFiles)]) %>% 
  lapply(read_csv) %>% 
  bind_rows

rdmDF2$subID = as.character(rdmDF2$subID)

rdmDF = bind_rows(rdmDF1, rdmDF2)


# post ROUND questions (difficulty, frequency of instructions)
rdmPostRoundQsdf1 <- file.path(rdmPath,rdmPostQFiles[1:99]) %>% 
  lapply(read_csv) %>% 
  bind_rows

rdmPostRoundQsdf2 <- file.path(rdmPath,rdmPostQFiles[100:length(rdmPostQFiles)]) %>% 
  lapply(read_csv) %>% 
  bind_rows

rdmPostRoundQsdf2$subID = as.character(rdmPostRoundQsdf2$subID)

rdmPostRoundQsdf = bind_rows(rdmPostRoundQsdf1, rdmPostRoundQsdf2)


rdmOutcomesDF1 <- file.path(rdmPath,rdmOutcomeFiles[1:99]) %>% 
  lapply(read_csv) %>% 
  bind_rows

rdmOutcomesDF2 <- file.path(rdmPath,rdmOutcomeFiles[100:length(rdmOutcomeFiles)]) %>% 
  lapply(read_csv) %>% 
  bind_rows

rdmOutcomesDF2$subID = as.character(rdmOutcomesDF2$subID)

rdmOutcomes = bind_rows(rdmOutcomesDF1,rdmOutcomesDF2)

ospanDF <- file.path(ospPath,ospFiles) %>% 
  lapply(read_csv) %>% 
  bind_rows

ospansubid = regmatches(ospFiles, regexpr("[0-9][0-9][0-9]", ospFiles)) # pulls out subid from file names
ospanDF$subID = rep(ospansubid, each = 25); # add subID column

symspanDF <- file.path(sspPath,sspFiles) %>% 
  lapply(read_csv) %>% 
  bind_rows

symspansubid = regmatches(sspFiles, regexpr("[0-9][0-9][0-9]", sspFiles)) # pulls out subid from file names
symspanDF$subID = rep(symspansubid, each = 14); # add subID column


# ERQ and Demographic

ERQdemoDF = read_csv(file.path(config$path$directory, 'data/rcsERQdemo.csv')) # when online 
#ERQdemoDF = read_csv("/Users/hayley/Desktop/RCS/data/rcsERQdemo.csv") # when offline

# Post-task questionnaires
postTask = read_csv(file.path(config$path$directory, 'data/rcsPostTaskQuestionnaire.csv')) # when online
#postTask = read_csv("/Users/hayley/Desktop/RCS/data/rcsPostTaskQuestionnaire.csv") # when offline

```

```{r save-for-OSF}

# RDM:
write_csv(rdmDF[,2:ncol(rdmDF)], file.path(config$path$directory,'data/rawDataForOSF/BrooksSokolHessner_RDM_rawData.csv'));

# RDM POST-ROUND:
write_csv(rdmPostRoundQsdf[,2:ncol(rdmPostRoundQsdf)], file.path(config$path$directory,'data/rawDataForOSF/BrooksSokolHessner_RDMpostRoundQs_rawData.csv'));

# OUTCOMES
# reformat before save
rdmOutcomesReformatted = as.data.frame(matrix(data=NA, nrow=134, ncol = 7, dimnames = list(c(NULL), c("subID", "round1trial","round1oc", "round2trial", "round2oc", "selectedOC","payment"))));
# clunky way to do this but...
startTri=1
increaseFactor = 4
for (s in 1:134) {

  rdmOutcomesReformatted$subID[s] = rdmOutcomes$subID[startTri];
  rdmOutcomesReformatted$round1trial[s] = rdmOutcomes$trial[startTri]
  rdmOutcomesReformatted$round1oc[s] = rdmOutcomes$outcome[startTri]
  rdmOutcomesReformatted$round2trial[s] = rdmOutcomes$trial[startTri+1]
  rdmOutcomesReformatted$round2oc[s] = rdmOutcomes$outcome[startTri+1]
  rdmOutcomesReformatted$selectedOC[s] = rdmOutcomes$subID[startTri+2]
  rdmOutcomesReformatted$payment[s] = rdmOutcomes$subID[startTri+3]
  
  # so clunky but it works
  startTri = s + increaseFactor
  increaseFactor= increaseFactor+3
  print(c(startTri,increaseFactor))
}


write_csv(rdmOutcomesReformatted, file.path(config$path$directory,'data/rawDataForOSF/BrooksSokolHessner_rdmOutcomes_rawData.csv'));


# OSPAN:
write_csv(ospanDF[,2:ncol(ospanDF)], file.path(config$path$directory,'data/rawDataForOSF/BrooksSokolHessner_ospan_rawData.csv'));

# SYMSPAN:
write_csv(symspanDF[,2:ncol(symspanDF)], file.path(config$path$directory,'data/rawDataForOSF/BrooksSokolHessner_symspan_rawData.csv'));

# ERQ + DEMO
ERQdemoTrimmed = ERQdemoDF[,18:ncol(ERQdemoDF)]
write_csv(ERQdemoTrimmed, file.path(config$path$directory,'data/rawDataForOSF/BrooksSokolHessner_ERQdemographic_rawData.csv'));

# POST TASK QUESTIONS
postTaskTrimmed  = postTask[,c(1,3:5)]
write_csv(postTaskTrimmed, file.path(config$path$directory,'data/rawDataForOSF/BrooksSokolHessner_postTask_rawData.csv'));


```



```{r variable-set-up, echo=FALSE}
nSub = length(unique(rdmDF$subID))
subIDchr = unique(rdmDF$subID)
#subID = 1:nSub
subID = as.numeric(subIDchr)
```


```{r load-conditions-file}

conditionsFile = read_csv(file.path(config$path$task_files, 'rdmTask/rcsConditionsUpdated_Winter.csv')) # online
#conditionsFile = read_csv("/Users/hayley/Documents/GitHub/rcs/task/rdmTask/rcsConditions.csv") # offline
#conditionsFile = conditionsFile[!conditionsFile$subID %in% excludeSubID,] # this applies exclusion
conditionsFile = conditionsFile[1:nSub,] # just include current participants up until this point

# condition code:
# 1 = control, control
# 2 = control, strategy
# 3 = strategy, control
# 4 = strategy, strategy

```

```{r group-level-stats, echo=FALSE}


cat("MISSED TRIALS: \n\nOverall:", sum(is.na(rdmDF$choice)), "\nMissed trials round 1:", sum(is.na(rdmDF$choice[rdmDF$roundRDM==1])), "\nMissed trials round 2:", sum(is.na(rdmDF$choice[rdmDF$roundRDM==2])))

cat("\n\nP(GAMBLE): \n\nOverall:",  mean(rdmDF$choice, na.rm = T), "\np(gamble) round 1:", mean(rdmDF$choice[rdmDF$roundRDM==1], na.rm = T), "\np(gamble) round 2:", mean(rdmDF$choice[rdmDF$roundRDM==2], na.rm = T))

cat("\n\nAVG RT: \n\nOverall:",  mean(rdmDF$RT, na.rm=T), "\nAvg RT round 1:", mean(rdmDF$RT[rdmDF$roundRDM==1], na.rm=T), "\nAvg RT round 2:", mean(rdmDF$RT[rdmDF$roundRDM==2], na.rm=T))

cat("\n\nNumber of subs who missed trial(s):", length(unique(rdmDF$subID[is.na(rdmDF$choice)])),"\n\nSubs who missed trials:", unique(rdmDF$subID[is.na(rdmDF$choice)]))


```


```{r set-up-variables-for-glm}
scaleFactor = max(rdmDF$riskyGain, na.rm=T)
rdmDF$gainScaled = rdmDF$riskyGain/scaleFactor
rdmDF$safeScaled = rdmDF$safe/scaleFactor
rdmDF$meanEV = (rdmDF$riskyGain*.5) + rdmDF$safe
rdmDF$meanEVscaled = rdmDF$meanEV/scaleFactor
```


```{r sub-level-QA, include=FALSE}
RDMqualityCheck = as.data.frame(matrix(data=NA, nrow=nSub, ncol=27, dimnames = list(c(NULL), c("subID", "round1missedT", "round2missedT","ShouldSafeRound1tot", "ShouldSafeRound1totMiss", "ShouldSafeRound1MissProportion", "ShouldGamRound1tot","ShouldGamRound1totMiss","ShouldGamRound1MissProportion","ShouldSafeRound2tot","ShouldSafeRound2totMiss","ShouldSafeRound2MissProportion","ShouldGamRound2tot", "ShouldGamRound2totMiss", "ShouldGamRound2MissProportion", "pgambleRound1", "pgambleRound2", "glmGainYesRound1", "glmSafeYesRound1", "glmGainYesRound2", "glmSafeYesRound2", "round1RTlowprop", "round2RTlowprop", "round2rt","round1rt", "round1strat", "round2strat"))));

RDMqualityCheck$subID = subID; # fill in sub IDs


#1) Missed trials

missToverall = aggregate(is.na(choice) ~subID, data=rdmDF, FUN=sum)
missTbyRound = aggregate(is.na(choice) ~subID + roundRDM, data=rdmDF, FUN=sum)

RDMqualityCheck$round1missedT = missTbyRound$`is.na(choice)`[missTbyRound$roundRDM==1]
RDMqualityCheck$round2missedT = missTbyRound$`is.na(choice)`[missTbyRound$roundRDM==2]

#2) p(gamble)
pGamOverall = aggregate(choice ~ subID, data = rdmDF, FUN = mean)
pGamByRound = aggregate(choice ~ subID + roundRDM, data = rdmDF, FUN = mean)

RDMqualityCheck$pgambleRound1 = pGamByRound$choice[pGamByRound$roundRDM==1]
RDMqualityCheck$pgambleRound2 = pGamByRound$choice[pGamByRound$roundRDM==2]

#3) glm (risky gain, safe, ev level)
  # tried mean EV instead of ev level- too similar to gain and safe
glmOverallresults  = list()
glmRound1results = list()
glmRound2results = list()

for (s in 1:nSub){
    subData = rdmDF[rdmDF$subID == subIDchr[s],] # subset data for participant 
    
    # basic glm across rounds
    #glmOverall = glm(choice ~ gainScaled + safeScaled + evLevel, data = subData) 
    #glmOverallresults[[s]] = summary(glmOverall) # store summary results
    
    # basic glm round 1
    glmRound1 = glm(choice ~ gainScaled + safeScaled + evLevel, data = subData[subData$roundRDM==1,]) 
    glmRound1results[[s]] = summary(glmRound1)# store summary results
    
    if(is.finite(glmRound1results[[s]]$coefficients[14]) & glmRound1results[[s]]$coefficients[14] < .05){ # check p-value for risky gain
      RDMqualityCheck$glmGainYesRound1[s] = 1; # if it is significant, this sub's choices were influenced by gain values
    } else{
      RDMqualityCheck$glmGainYesRound1[s] = 0; # otherwise, this sub's choices were not influenced by gain values
    };
    
    if(is.finite(glmRound1results[[s]]$coefficients[15]) & glmRound1results[[s]]$coefficients[15] < .05){ # check p-value for safe
      RDMqualityCheck$glmSafeYesRound1[s] = 1; # if it is significant, this sub's choices were influenced by safe values
    } else{
      RDMqualityCheck$glmSafeYesRound1[s] = 0; # otherwise, this sub's choices were not influenced by safe values
    };
    
    # basic glm round 2
    glmRound2 = glm(choice ~ gainScaled + safeScaled + evLevel, data = subData[subData$roundRDM==2,]) 
    glmRound2results[[s]] = summary(glmRound2)# store summary results
    
    if(is.finite(glmRound2results[[s]]$coefficients[14]) & glmRound2results[[s]]$coefficients[14] < .05){ # check p-value for risky gain
      RDMqualityCheck$glmGainYesRound2[s] = 1; # if it is significant, this sub's choices were influenced by gain values
    } else{
      RDMqualityCheck$glmGainYesRound2[s] = 0; # otherwise, this sub's choices were not influenced by gain values
    };
    
    if(is.finite(glmRound2results[[s]]$coefficients[15]) & glmRound2results[[s]]$coefficients[15] < .05){ # check p-value for safe
      RDMqualityCheck$glmSafeYesRound2[s] = 1; # if it is significant, this sub's choices were influenced by safe values
    } else{
      RDMqualityCheck$glmSafeYesRound2[s] = 0; # otherwise, this sub's choices were not influenced by safe values
    };
    
}


#4) missed attention checks
# Subset trials where participants should have played it safe
shouldNotGamble = rdmDF[rdmDF$safe >= rdmDF$riskyGain,];
shouldNotGambleRound1 = shouldNotGamble[shouldNotGamble$roundRDM==1,]; 
shouldNotGambleRound2 = shouldNotGamble[shouldNotGamble$roundRDM==2,]; 

# see which participants missed those trials
#shouldNotGambleMiss = aggregate(choice~subID, data=shouldNotGamble, FUN=sum)
shouldNotGambleMiss = shouldNotGamble[shouldNotGamble$choice==1 | is.na(shouldNotGamble$choice),];
shouldNotGambleMissRound1 = shouldNotGambleMiss[shouldNotGambleMiss$roundRDM==1,];
shouldNotGambleMissRound2 = shouldNotGambleMiss[shouldNotGambleMiss$roundRDM==2,];
#shouldNotGambleMissRound1 = aggregate(choice~subID, data=shouldNotGambleRound1, FUN=sum)
#shouldNotGambleMissRound2 = aggregate(choice~subID, data=shouldNotGambleRound2, FUN=sum)


# Choices where participants should have gambled (safe = $0)
shouldGamble = rdmDF[rdmDF$safe==0,]; 
shouldGambleRound1 = shouldGamble[shouldGamble$roundRDM==1,]; 
shouldGambleRound2 = shouldGamble[shouldGamble$roundRDM==2,];

# How many of these "should gamble" choices did participants miss?

shouldGambleMiss = shouldGamble[shouldGamble$choice==0 | is.na(shouldGamble$choice),];
shouldGambleMissRound1 = shouldGambleMiss[shouldGambleMiss$roundRDM==1,];
shouldGambleMissRound2 = shouldGambleMiss[shouldGambleMiss$roundRDM==2,];


# Store the total number of attention checks, the number missed, and the proportion of missed attention checks. 
for (s in 1:nSub) {
  
  # how many total "should safe" (i.e. "should not gamble") trials did each participant encounter?
  RDMqualityCheck$ShouldSafeRound1tot[s] = nrow(shouldNotGambleRound1[shouldNotGambleRound1$subID==subIDchr[s],]); # Round 1
  RDMqualityCheck$ShouldSafeRound2tot[s] = nrow(shouldNotGambleRound2[shouldNotGambleRound2$subID==subIDchr[s],]); # Round 2
  
  # how many of these "should safe" trials did they miss?
  RDMqualityCheck$ShouldSafeRound1totMiss[s] = nrow(shouldNotGambleMissRound1[shouldNotGambleMissRound1$subID==subIDchr[s],]); # Round 1
  RDMqualityCheck$ShouldSafeRound2totMiss[s] = nrow(shouldNotGambleMissRound2[shouldNotGambleMissRound2$subID==subIDchr[s],]); # Round 2
  
  
  # how many total "should gamble" trials did each participant encounter?
  RDMqualityCheck$ShouldGamRound1tot[s]=nrow(shouldGambleRound1[shouldGambleRound1$subID==subIDchr[s],]); # Round 1
  RDMqualityCheck$ShouldGamRound2tot[s]=nrow(shouldGambleRound2[shouldGambleRound2$subID==subIDchr[s],]); # Round 2
  
  # how many of these "should gamble" trials did they miss?
  RDMqualityCheck$ShouldGamRound1totMiss[s]=nrow(shouldGambleMissRound1[shouldGambleMissRound1$subID==subIDchr[s],]); # Round 1
  RDMqualityCheck$ShouldGamRound2totMiss[s]=nrow(shouldGambleMissRound2[shouldGambleMissRound2$subID==subIDchr[s],]); # Round 2

  
  # What proportion of the "should safe" and "should gamble" trials did participants miss?
    # 0 = no misses; 1 = all missed
  
  # "should safe"
  RDMqualityCheck$ShouldSafeRound1MissProportion[s] = RDMqualityCheck$ShouldSafeRound1totMiss[s]/RDMqualityCheck$ShouldSafeRound1tot[s]; # Round 1
  RDMqualityCheck$ShouldSafeRound2MissProportion[s] = RDMqualityCheck$ShouldSafeRound2totMiss[s]/RDMqualityCheck$ShouldSafeRound2tot[s]; # Round 2
  
  # "should gamble"
  RDMqualityCheck$ShouldGamRound1MissProportion[s] = RDMqualityCheck$ShouldGamRound1totMiss[s]/RDMqualityCheck$ShouldGamRound1tot[s]; # Round 1
  RDMqualityCheck$ShouldGamRound2MissProportion[s] = RDMqualityCheck$ShouldGamRound2totMiss[s]/RDMqualityCheck$ShouldGamRound2tot[s]; # Round 2
  
};




# Reaction time
# save mean reaction time
rtByRound = aggregate(RT ~ subID + roundRDM, data = rdmDF, FUN = mean) 
RDMqualityCheck$round1rt = rtByRound$RT[rtByRound$roundRDM==1]
RDMqualityCheck$round2rt = rtByRound$RT[rtByRound$roundRDM==2]


# look proportion of rts that are =< 1
for(s in 1:nSub){
  subData = rdmDF[rdmDF$subID==subIDchr[s],]
  RDMqualityCheck$round1lowRTprop[s]= sum(subData$RT[subData$roundRDM==1]<=1, na.rm=T)/nrow(subData[subData$roundRDM==1,])
  RDMqualityCheck$round2lowRTprop[s]= sum(subData$RT[subData$roundRDM==2]<=1, na.rm=T)/nrow(subData[subData$roundRDM==2,])
}


# condition (natural vs strategy in rounds 1 and 2)
condByRound =aggregate(strategy ~ subID + roundRDM, data = rdmDF, FUN=mean)# using mean - output is still 0 or 1
RDMqualityCheck$round1strat = condByRound$strategy[condByRound$roundRDM==1]
RDMqualityCheck$round2strat = condByRound$strategy[condByRound$roundRDM==2]




```

```{r plot-and-save-choices, echo=FALSE, include=FALSE}
pdf(file.path(config$path$directory,config$path$shlab_figures, 'participantChoices.pdf'))
for(s in 1:nSub){
  subRound1 = rdmDF[rdmDF$subID==subIDchr[s] & rdmDF$roundRDM==1,]
subRound2 =  rdmDF[rdmDF$subID==subIDchr[s] & rdmDF$roundRDM==2,]

if (unique(subRound1$strategy==0)){
  condition1 = "act natural"
} else {
  condition1 = "strategy"
}

if (unique(subRound2$strategy==0)){
  condition2 = "act natural"
} else {
  condition2 = "strategy"
}

par(mfrow=c(1,2))
plot(subRound1$safe,subRound1$riskyGain, main = sprintf("Round 1 choices for sub-%s\n%s; p(gam): %.2f", subIDchr[s], condition1, RDMqualityCheck$pgambleRound1[RDMqualityCheck$subID==subID[s]]), pch = 16, col=(subRound1$choice/.55)+2, ylab = "risky gain ($)", xlab="safe ($)", asp=1)
plot(subRound2$safe,subRound2$riskyGain, main = sprintf("Round 2 choices for sub-%s\n%s; p(gam): %.2f", subIDchr[s], condition2, RDMqualityCheck$pgambleRound2[RDMqualityCheck$subID==subID[s]]), pch = 16, col=(subRound2$choice/.55)+2, ylab = "risky gain ($)", xlab="safe ($)", asp=1)

}
dev.off()




```

## FLAG PROBLEMATIC PARTICIPANTS who:
  - 1) missed more than 10% of trials (more than 13 trials in each round)
  - 2) missed too many attention checks (at least 30% of attention check trials)
  - 3) pgamble is less than .05 and greater than .95 
  - 4) were not influenced by gain and safe
  - 5) responses were too fast

```{r determine-exclusion-rdm, echo=FALSE}
# Set thresholds:
missTriThresh = 13;     # cut off for proportion of missed trials (i.e. participants "fail" if they missed more than this number)
pgamLowThresh = .05;    # lower end of pgamble threshold (pgambles lower than this will be considered a "fail")
pgamHighThresh = .95;   # higher end of pgamble threshold (pgambles higher than this will be considered a "fail")
missACprop = .3;        # proportion of missed attention checks; (any number higher than this would be a "fail")
minACtotal = 4;         # participant had atleast this number of attention check trials
minRT = 1               # 1s minimum for RT? Should we do something like 2 +/- sd?
#minRTprop = 13
#CHANGE RT TO BE PROPORTION OF TRIALS WITH LOW RTS?

# Create the data frames for output 1 and 2:
passFailCategories = c("subID","missT", "missACs", "pgamble", "glm", "rt"); # column names
round1passfail = as.data.frame(matrix(data=NA, nrow=nSub, ncol=length(passFailCategories),dimnames = list(c(NULL), passFailCategories))); # round1
round2passfail = as.data.frame(matrix(data=NA, nrow=nSub, ncol=length(passFailCategories),dimnames = list(c(NULL), passFailCategories))); # round2

# fill in sub IDs
round1passfail$subID=1:nSub; # round 1 
round2passfail$subID=1:nSub; # round 2


# 1) MISSED TRIALS 
# round 1:
round1passfail$missT[which(RDMqualityCheck$round1missedT > missTriThresh)] = 0;  # 0 if they missed more trials than threshold
round1passfail$missT[which(RDMqualityCheck$round1missedT <= missTriThresh)] = 1; # 1 if they missed less trials than threshold

# round 2: 
round2passfail$missT[which(RDMqualityCheck$round2missedT > missTriThresh)] = 0;  # 0 if they missed more trials than threshold
round2passfail$missT[which(RDMqualityCheck$round2missedT <= missTriThresh)] = 1; # 1 if they missed less trials than threshold


# 2) ATTENTION CHECKS:

# round 1: 
# range of total attention checks per person = 6-20 trials
# range of total missed attention checks = 0-2
# range of proportion missed = 0-.1; median = 0; mean = .02

# Which participants had at least the number of attention check trials we set as the threshold and also missed a proportion of these trials above our set threshold?
missACindRound1 = which((RDMqualityCheck$ShouldGamRound1totMiss + RDMqualityCheck$ShouldSafeRound1totMiss)/(RDMqualityCheck$ShouldGamRound1tot + RDMqualityCheck$ShouldSafeRound1tot) > missACprop & (RDMqualityCheck$ShouldGamRound1tot + RDMqualityCheck$ShouldSafeRound1tot)>minACtotal); 


round1passfail$missACs[missACindRound1] = 0;  # 0 = fail
round1passfail$missACs[-missACindRound1] = 1; # 1 = pass

if(length(missACindRound1)==0){
  round1passfail$missACs=1
}



# Round 2:
# range of total attention checks per person = 6-18 trials
# range of missed attention checks: 0-4
# range of proportion missed = 0-.44; median = 0; mean = .04;

# Which participants had at least the number of attention check trials we set as the threshold and also missed a proportion of these trials above our set threshold?
missACindRound2 = which((RDMqualityCheck$ShouldGamRound2totMiss + RDMqualityCheck$ShouldSafeRound2totMiss)/(RDMqualityCheck$ShouldGamRound2tot + RDMqualityCheck$ShouldSafeRound2tot) > missACprop & (RDMqualityCheck$ShouldGamRound2tot + RDMqualityCheck$ShouldSafeRound2tot)>minACtotal);


round2passfail$missACs[missACindRound2] = 0;  # 0 = fail
round2passfail$missACs[-missACindRound2] = 1; # 1 = pass

if(length(missACindRound2)==0){
  round2passfail$missACs=0
}



# 3) PROBABILITY OF GAMBLING NEAR BOUNDS
    # 0 = pgamble higher or lower than threshold
    # 1 = pgamble within and including the threshold limits

# round 1
round1passfail$pgamble[which(RDMqualityCheck$pgambleRound1 > pgamHighThresh | RDMqualityCheck$pgambleRound1 < pgamLowThresh)]=0;
round1passfail$pgamble[which(RDMqualityCheck$pgambleRound1 <= pgamHighThresh & RDMqualityCheck$pgambleRound1 >= pgamLowThresh)]=1;

# round 2
round2passfail$pgamble[which(RDMqualityCheck$pgambleRound2 > pgamHighThresh | RDMqualityCheck$pgambleRound2 < pgamLowThresh)]=0;
round2passfail$pgamble[which(RDMqualityCheck$pgambleRound2 <= pgamHighThresh & RDMqualityCheck$pgambleRound2 >= pgamLowThresh)]=1;




# 4)  CHOICES INFLUENCED BY GAINS AND SAFE (gain-only task)
  # 0 = not influened by either safe or gain values
  # 1 = influenced by safe or gain values

# round 1
round1passfail$glm[which(RDMqualityCheck$glmGainYesRound1==0 & RDMqualityCheck$glmSafeYesRound1==0)] = 0;  # fail
round1passfail$glm[which(RDMqualityCheck$glmGainYesRound1==1 & RDMqualityCheck$glmSafeYesRound1==0)] = 1;  # pass
round1passfail$glm[which(RDMqualityCheck$glmGainYesRound1==0 & RDMqualityCheck$glmSafeYesRound1==1)] = 1;  # pass
round1passfail$glm[which(RDMqualityCheck$glmGainYesRound1==1 & RDMqualityCheck$glmSafeYesRound1==1)] = 1;  # pass

# round 2
round2passfail$glm[which(RDMqualityCheck$glmGainYesRound2==0 & RDMqualityCheck$glmSafeYesRound2==0)] = 0;  # fail
round2passfail$glm[which(RDMqualityCheck$glmGainYesRound2==1 & RDMqualityCheck$glmSafeYesRound2==0)] = 1;  # pass
round2passfail$glm[which(RDMqualityCheck$glmGainYesRound2==0 & RDMqualityCheck$glmSafeYesRound2==1)] = 1;  # pass
round2passfail$glm[which(RDMqualityCheck$glmGainYesRound2==1 & RDMqualityCheck$glmSafeYesRound2==1)] = 1;  # pass


#5) Reaction time
# round 1
round1passfail$rt[which(RDMqualityCheck$round1rt <minRT)]=0
round1passfail$rt[which(RDMqualityCheck$round1rt >=minRT)]=1

# round 2
round2passfail$rt[which(RDMqualityCheck$round2rt <minRT)]=0
round2passfail$rt[which(RDMqualityCheck$round2rt >=minRT)]=1


# BASED ON THE PASS/FAIL IN CRITERIA ABOVE, WHO ARE WE EXCLUDING?
# For each participant, what is the sum of their pass/fail results (5=passed all criteria; 0= passed none)

# What is our cut off for determining who gets excluded and who stays?
    # If our cut off is missing more than 1 (ie we only keep 4s and 5s), 
     # This criteria captures a lot (not all) of the participants with glm = 0 (choices not influenced by gain or safe values). 
     # there will be participants w/ 4s who missed the glm criteria 
     #    if data is good otherwise, perhaps their choices were influenced by some of the things we are interested in (e.g. context!)

   # If our cut off is missing more than 2 (we keep 3-5s), we exclude less: 

# How did each participant do?
  # For each participant, store the total of pass/fails, where 5 = perfect, 0 = failed each criteria
round1passfail$total=rowSums(round1passfail[2:6]); # range = 3-5; mean = 4.84
round2passfail$total=rowSums(round2passfail[2:6]); # range = 3-5; mean = 4.72

# Create data frame for output #3:
rdmExclude = as.data.frame(matrix(data=NA, nrow = nSub, ncol=4, dimnames=list(c(NULL), c("subID", "round1Exclude", "round2Exclude", "rdmExcludeOverall"))));

rdmExclude$subID = 1:nSub; # fill in sub ID

excludeCutOff = 4; # we are only keeping those with totals at or above this number

# phase 1:
rdmExclude$round1Exclude[round1passfail$total<excludeCutOff] = 1; # exclude if they missed more than 2 
rdmExclude$round1Exclude[round1passfail$total>=excludeCutOff] = 0; # otherwise, keep

# phase 2:
rdmExclude$round2Exclude[round2passfail$total<excludeCutOff] = 1; # exclude if they missed more than 2 
rdmExclude$round2Exclude[round2passfail$total>=excludeCutOff] = 0; # otherwise, keep

# overall: we are excluding participants from both rounds if they met exclusion criteria for both rounds. 
rdmExclude$rdmExcludeOverall[rdmExclude$round1Exclude + rdmExclude$round2Exclude >0] = 1
rdmExclude$rdmExcludeOverall[rdmExclude$round1Exclude + rdmExclude$round2Exclude ==0] = 0


# excluding based on self-report?
  # sub-012: self reported pressing both v+n in the second round and their glm reflects that (their choices are not influenced by gain or safe values on the screen)
  # sub-015: self reported choosing options based on trying to detect patterns in the task (e.g. selected gamble on right and would select gamble on the right again to see if there was some likelihood of winning based on side of screen gamble was on). Glm also reflects this.

rdmExclude$round1Exclude[subID==12] = 1
rdmExclude$round2Exclude[subID==12] = 1
rdmExclude$rdmExcludeOverall[subID==12] = 1

rdmExclude$round1Exclude[subID==15] = 1
rdmExclude$round2Exclude[subID==15] = 1
rdmExclude$rdmExcludeOverall[subID==15] = 1

excludeSubID = rdmExclude$subID[rdmExclude$rdmExcludeOverall==1]
cat("\nParticipants to exclude:",excludeSubID)

rdmDF = as.data.frame(rdmDF);

# save(RDMqualityCheck, file ="/Users/hayley/Desktop/RCS/data/Rdata/rdmQualityCheck.Rdata")
# save(rdmExclude, file = "/Users/hayley/Desktop/RCS/data/Rdata/rdmExclude.Rdata")
# save(round1passfail, file = "/Users/hayley/Desktop/RCS/data/Rdata/round1passfail.Rdata")
# save(round2passfail, file = "/Users/hayley/Desktop/RCS/data/Rdata/round2passfail.Rdata")

# for online:
save(RDMqualityCheck, file = file.path(config$path$data$Rdata, 'rdmQualityCheck.Rdata'))
save(rdmExclude, file = file.path(config$path$data$Rdata, 'rdmExclude.Rdata'))
save(round1passfail, file = file.path(config$path$data$Rdata, 'round1passfail.Rdata'))
save(round2passfail, file = file.path(config$path$data$Rdata, 'round2passfail.Rdata'))

```

For complex span exclusion, participants will only be excluded from the specific span tasks that they do not pass the 85% criteria (rather than excluding across both span tasks).

Note: Subs 37 and 82 did not complete ospan or symspan task
```{r complex-span-tasks-exclusion, echo=FALSE}



complexSpanExclude = as.data.frame(matrix(data=NA, nrow = nSub, ncol=3, dimnames=list(c(NULL), c("subID", "ospanExclude", "symspanExclude"))));

complexSpanExclude$subID = 1:nSub # 



# participants had to keep percent correct symmetry at 85% or above
if (any(symspanDF$percentCorrectSym[symspanDF$...1==14]<85)){
  symspanExclude = symspanDF$subID[symspanDF$...1 ==14 & symspanDF$percentCorrectSym <85]
  complexSpanExclude$symspanExclude[complexSpanExclude$subID %in% as.numeric(symspanExclude)] = 1
  
}

# participants had to keep percent correct math at 85% or above
if (any(ospanDF$percentCorrectMath[ospanDF$...1==25]<85)){
  ospanExclude = ospanDF$subID[ospanDF$...1 ==25 & ospanDF$percentCorrectMath <85]
  complexSpanExclude$ospanExclude[complexSpanExclude$subID %in% as.numeric(ospanExclude)] = 1

}

# manually exclude sub 37 and 82 for not completing the tasks
symspanExclude = c(symspanExclude,"037", "082")
ospanExclude = c(ospanExclude,"037", "082")
complexSpanExclude[37,2:3] = 1
complexSpanExclude[82,2:3] = 1

cat("COMPLEX SPAN EXCLUSION SUB IDS: \n\nSYMSPAN:", symspanExclude, "\nOSPAN:", ospanExclude)


complexSpanExclude[is.na(complexSpanExclude[,])]=0


```

```{r score-complex-span-tasks}
# The scoring dataframes include scores for ALL participants (even those who's data we aren't using because of less than 85% accuracy)

#OSPAN Absolute Score: The sum of the correctly recalled elements from only the items in which all the elements are recalled in correct serial order (formally OSPAN Score)

#SSPAN Absolute Score: The sum of the correctly recalled elements from only the items in which all the elements are recalled in correct serial order (formally SSPAN Score)

complexSpanScores = as.data.frame(matrix(data=NA, nrow = nSub, ncol=4, dimnames=list(c(NULL), c("subID", "ospanScore", "symspanScore", "compositeSpanScore"))));
complexSpanScores$subID= 1:nSub


for (s in 1:nrow(complexSpanScores)) {
  singleSubOspan = ospanDF[ospanDF$subID==subIDchr[s],]
  correctIndospan = which(singleSubOspan$correctCount == singleSubOspan$setSize)
  complexSpanScores$ospanScore[s] = sum(singleSubOspan$correctCount[correctIndospan])
  
  singleSubSymspan = symspanDF[symspanDF$subID==subIDchr[s],]
  correctIndsymspan = which(singleSubSymspan$squareCorrectCount == singleSubSymspan$setSize)
  complexSpanScores$symspanScore[s] = sum(singleSubSymspan$squareCorrectCount[correctIndsymspan])

  complexSpanScores$compositeSpanScore[s] = mean(c((complexSpanScores$ospanScore[s]/25),(complexSpanScores$symspanScore[s]/14)))
}



# now that we have scored everyone's complex span tasks, apply exclusion to our big dataframe.
symspanDF = symspanDF[which(!symspanDF$subID %in% symspanExclude),] # apply exclusion
ospanDF = ospanDF[which(!ospanDF$subID %in% ospanExclude),] # apply exclusion



```

```{r save-complex-span-tasks, include=FALSE}
# when offline
# save(ospanDF, file = "/Users/hayley/Desktop/RCS/data/Rdata/ospan_clean.Rdata")
# save(symspanDF, file = "/Users/hayley/Desktop/RCS/data/Rdata/symspan_clean.Rdata")
# save(complexSpanExclude, file = "/Users/hayley/Desktop/RCS/data/Rdata/complexSpanExclusion.Rdata")
# save(complexSpanScores, file="/Users/hayley/Desktop/RCS/data/Rdata/complexSpanScores.Rdata")

# for online
save(ospanDF, file = file.path(config$path$data$Rdata, 'ospan_clean.Rdata'))
save(symspanDF, file = file.path(config$path$data$Rdata, 'symspan_clean.Rdata'))
save(complexSpanExclude, file = file.path(config$path$data$Rdata, 'complexSpanExclusion.Rdata'))
save(complexSpanScores, file=file.path(config$path$data$Rdata, 'complexSpanScores.Rdata'))

```

Score ERQ, each participant will have a reappraisal and suppression score  
```{r score-and-save-ERQ, echo=FALSE}
#reappraisal: 1,3,5,7,8,10
reappraisalScores = cbind(as.numeric(ERQdemoDF$ERQ_1[3:nrow(ERQdemoDF)]),as.numeric(ERQdemoDF$ERQ_3[3:nrow(ERQdemoDF)]), as.numeric(ERQdemoDF$ERQ_5[3:nrow(ERQdemoDF)]),as.numeric(ERQdemoDF$ERQ_7[3:nrow(ERQdemoDF)]), as.numeric(ERQdemoDF$ERQ_8[3:nrow(ERQdemoDF)]),as.numeric(ERQdemoDF$ERQ_10[3:nrow(ERQdemoDF)]))

reappraisalSums = rowSums(reappraisalScores)
reappraisalMeans = rowMeans(reappraisalScores)



#suppression: 2, 4, 6, 9
suppressionScores = cbind(as.numeric(ERQdemoDF$ERQ_2[3:nrow(ERQdemoDF)]), as.numeric(ERQdemoDF$ERQ_4[3:nrow(ERQdemoDF)]), as.numeric(ERQdemoDF$ERQ_6[3:nrow(ERQdemoDF)]), as.numeric(ERQdemoDF$ERQ_9[3:nrow(ERQdemoDF)]))

suppressionSums = rowSums(suppressionScores)
suppressionMeans = rowMeans(suppressionScores)

reapprGroupMean = mean(reappraisalMeans, na.rm=T)
suppGroupMean =mean(suppressionMeans, na.rm=T)
hist(reappraisalMeans, main=sprintf("Reappraisal scores for N = %.0f \nMean = %.02f",nSub,reapprGroupMean)) 
hist(suppressionMeans, main=sprintf("Supression scores for N = %.0f \nMean = %.02f",nSub,suppGroupMean)) 

# have not applied any exclusion at this point
ERQscores = cbind(subID,reappraisalSums, reappraisalMeans, suppressionSums, suppressionMeans)
ERQscores = as.data.frame(ERQscores)
colnames(ERQscores) = c("subID", "reappraisalSums", "reappraisalMeans", "suppressionSums", "suppressionMeans")


ERQexclude = as.data.frame(matrix(data=NA, nrow = nSub, ncol=2, dimnames=list(c(NULL), c("subID", "ERQexclude"))));
ERQexclude$subID = 1:nSub;

ERQexclude$ERQexclude[is.na(ERQscores$reappraisalSums+ERQscores$suppressionSums)] = 1
ERQexclude$ERQexclude[is.na(ERQexclude$ERQexclude)] = 0



# for online
save(ERQscores, file = file.path(config$path$data$Rdata, 'ERQscores.Rdata'))
save(ERQexclude, file = file.path(config$path$data$Rdata, 'ERQexclude.Rdata'))


```

```{r create-big-exclusion-matrix}
rcsAllExclusion = cbind(rdmExclude, ERQexclude$ERQexclude, complexSpanExclude$ospanExclude, complexSpanExclude$symspanExclude)

colnames(rcsAllExclusion) = c("subID", "rdm1exclude", "rdm2exclude","rdmOverall", "ERQexclude", "ospanExclude", "symspanExclude")

#save(rcsAllExclusion, file = "/Users/hayley/Desktop/RCS/data/Rdata/rcsAllExclusion.Rdata") # offline

save(rcsAllExclusion, file=file.path(config$path$data$Rdata, 'rcsAllExclusion.Rdata')) # online

```


```{r clean-up-recode-demo-questions}
demographic = ERQdemoDF[,c(18,29:ncol(ERQdemoDF))]
colnames(demographic) = c("subID", "gender", "genderOther", "race", "raceOther", "ethnicity", "age")
demographic = demographic[3:nrow(demographic),]
demographic$age = as.numeric(demographic$age)

# gender coding
# 1 = Male
# 2 = Female
# 3 = Trans Male
# 4 = Trans Female
# 5 = Gender nonconforming
# 6 = Other
# 7 = Decline to answer

demographic$genderCode[demographic$gender=="Male"] =1
demographic$genderCode[demographic$gender=="Female"] =2
demographic$genderCode[demographic$gender=="Trans Male"] =3
demographic$genderCode[demographic$gender=="Trans Female"] =4
demographic$genderCode[demographic$gender=="Gender nonconforming"] =5
demographic$genderCode[demographic$gender=="Other"] =6
demographic$genderCode[demographic$gender=="Decline to answer"] = 7

# race coding
# 1 = White
# 2 = Black or African American American
# 3 = American Indian and Alaskan Native
# 4 = Asian
# 5 = Native Hawaiian and Other Pacific Islander
# 6 = Two or more races
# 7 = Other
# 8 = Decline to answer

demographic$raceCode[demographic$race=="White"] =1
demographic$raceCode[demographic$race=="Black or African American"] =2
demographic$raceCode[demographic$race=="American Indian and Alaskan Native"] =3
demographic$raceCode[demographic$race=="Asian"] =4
demographic$raceCode[demographic$race=="Native Hawaiian and Other Pacific Islander"] =5
demographic$raceCode[demographic$race=="Two or more races"] =6
demographic$raceCode[demographic$race=="Other"] = 7
demographic$raceCode[demographic$race=="Decline to answer"] = 8

# ethnicity
# 1 = Hispanic or Latino
# 2 = Not Hispanic or Latino
demographic$ethnicityCode[demographic$ethnicity=="Hispanic or Latino"] = 1
demographic$ethnicityCode[demographic$ethnicity=="Not Hispanic or Latino"] = 2

#save(demographic, file="/Users/hayley/Desktop/RCS/data/Rdata/demographic.Rdata") # offline
save(demographic, file=file.path(config$path$data$Rdata, 'demographic.Rdata')) # online

```


```{r clean-and-save-posttask-postround-qs}

postTaskNumericOnly = postTask[2:nrow(postTask),c(1,3:5)]
colnames(postTaskNumericOnly) = c("subID", "rdmOverallDifficulty", "motivation", "roundsIndependent")

#save(postTaskNumericOnly, file = "/Users/hayley/Desktop/RCS/data/Rdata/postTaskNumericOnly.Rdata") # for offline
save(postTaskNumericOnly, file=file.path(config$path$data$Rdata, 'postTaskNumericOnly.Rdata')) # for online


# add condition/strategy to this dataframe 
rdmPostRoundQsdf$strategy[rdmPostRoundQsdf$...1==1] = RDMqualityCheck$round1strat
rdmPostRoundQsdf$strategy[rdmPostRoundQsdf$...1==2] = RDMqualityCheck$round2strat


# add condition code to dataframe 
# 1 = natural, natural
# 2 = natural, strategy
# 3 = strategy, natural
# 4 = strategy, strategy
rdmPostRoundQsdf$condCode = rep(conditionsFile$condCode, each=2)

# save as post round Rdata
#save(rdmPostRoundQsdf,file ="/Users/hayley/Desktop/RCS/data/Rdata/rdmPostRoundQs.Rdata") # for offline
save(rdmPostRoundQsdf, file=file.path(config$path$data$Rdata, 'rdmPostRoundQs.Rdata')) # for online

```

```{r clean-and-save-selectedOutcomes}
# each participant has 4 rows. trial and outcome selected on round 1, round 2, and at the end, and the 1/2 payment amount
# we want each participant to have 1 row with 4 columns: outcomeRound1, outcomeRound2, outcomeSelected, outcomePayment

rdmOutcomesClean = as.data.frame(matrix(data=NA, nrow=nSub, ncol = 4, dimnames=list(c(NULL), c("ocRound1", "ocRound2", "ocFinal", "ocPayment"))))

for (s in 1:nSub) {
  rowInd = which(rdmOutcomes$subID==subIDchr[s]) # which rows have subID[s]
  rowInd = c(rowInd, rowInd[2]+1, rowInd[2]+2) # each sub has two extra rows without their subID
  
  sub = rdmOutcomes[rowInd,]
  
  rdmOutcomesClean$ocRound1[s] = sub$outcome[1]
  rdmOutcomesClean$ocRound2[s] = sub$outcome[2]
  rdmOutcomesClean$ocFinal[s] = as.numeric(sub$subID[3]) # weird formatting where 3rd row of subID in sub is selected outcome (full)
  rdmOutcomesClean$ocPayment[s] = as.numeric(sub$subID[4]) # similar as above where 4th row of subID in sub is selected outcome * .5 for payment
}

#offline
#save(rdmOutcomesClean, file="/Users/hayley/Desktop/RCS/data/Rdata/rdmOutcomes.Rdata")

#online
save(rdmOutcomesClean, file=file.path(config$path$data$Rdata, 'rdmOutcomes.Rdata'))

```


```{r combine-rdm-with-everything-else}
# rdmDF_clean.Rdata + ospan, symspan, ERQ, demographic, post round Qs, post-task questionnaires (the numeric ones) 

# ALL PARTICIPANTS (NO EXCLUSIONS ACROSS THE BOARD):
nT = 131
rounds = 2

rdmDF$ospanScore = rep(complexSpanScores$ospanScore, each = nT*rounds)
rdmDF$symSpanScore = rep(complexSpanScores$symspanScore, each = nT*rounds)
rdmDF$compositeSpanScore = rep(complexSpanScores$compositeSpanScore, each = nT*rounds)
rdmDF$ERQreappraisalMean = rep(ERQscores$reappraisalMeans, each = nT*rounds)
rdmDF$ERQsuppressionMean = rep(ERQscores$suppressionMeans, each = nT*rounds)
rdmDF$ERQreappraisalSum = rep(ERQscores$reappraisalSums, each = nT*rounds)
rdmDF$ERQsuppressionSum = rep(ERQscores$suppressionSums, each = nT*rounds)
rdmDF$age = rep(demographic$age, each = nT*rounds)
rdmDF$gender = rep(demographic$gender, each = nT*rounds)
rdmDF$genderCode = rep(demographic$genderCode, each = nT*rounds)
rdmDF$race = rep(demographic$race, each = nT*rounds)
rdmDF$raceCode = rep(demographic$raceCode, each = nT*rounds)
rdmDF$ethnicity = rep(demographic$ethnicity, each =nT*rounds)
rdmDF$ethnicityCode = rep(demographic$ethnicityCode, each =nT*rounds)
rdmDF$instDifficulty = rep(rdmPostRoundQsdf$difficulty, each = nT)
rdmDF$instHowOften = rep(rdmPostRoundQsdf$howOften, each=nT)
rdmDF$rdmOverallDiff = rep(postTaskNumericOnly$rdmOverallDifficulty, each = nT*rounds)
rdmDF$overallMotivation = rep(postTaskNumericOnly$motivation, each = nT*rounds)
rdmDF$rdmRoundsIndependent = rep(postTaskNumericOnly$roundsIndependent, each = nT*rounds)
rdmDF$round1oc = rep(rdmOutcomesClean$ocRound1, each = nT*rounds)
rdmDF$round2oc = rep(rdmOutcomesClean$ocRound2, each = nT*rounds)
rdmDF$ocSelected = rep(rdmOutcomesClean$ocFinal,each = nT*rounds)
rdmDF$ocPayment = rep(rdmOutcomesClean$ocPayment, each = nT*rounds)

# CREATE CLEAN VERSION OF rdmDF (that we just added a bunch of variables to right above)
# applying exclusion across the board
# removing all data for participants who are excluded from RDM and then removing missed rdm trials for included subs
# putting NA for participants who are included in RDM but were excluded from other measures.

# apply exclusions to rdm data:
rdmDFclean = rdmDF[which(!as.numeric(rdmDF$subID) %in% excludeSubID),]

# removed missed trials from RDM:
nanInd = which(is.na(rdmDFclean$choice));
totNan = length(nanInd); # # of missed trials after removing participants
subIDNan = unique(rdmDFclean$subID[nanInd]); # participants with missed trials
totalSubsNan = length(subIDNan) # number of subs who missed
rdmDFclean = rdmDFclean[which(!is.nan(rdmDFclean$choice)),]; #remove missed trials

RDMqualityCheck_clean = RDMqualityCheck[which(!as.numeric(RDMqualityCheck$subID) %in% excludeSubID),]; # quality variables for those who are not excluded


# For other variables that are excluded for participants, replace with NA
# (ospan, symspan, ERQ)

rdmDFclean$ospanScore[which(rdmDFclean$subID %in% ospanExclude)] = NA
rdmDFclean$symSpanScore[which(rdmDFclean$subID %in% symspanExclude)] = NA
rdmDFclean$compositeSpanScore[which(rdmDFclean$subID %in% c(ospanExclude, symspanExclude))] =NA
rdmDFclean$ERQreappraisalMean[which(as.numeric(rdmDFclean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rdmDFclean$ERQsuppressionMean[which(as.numeric(rdmDFclean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rdmDFclean$ERQreappraisalSum[which(as.numeric(rdmDFclean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rdmDFclean$ERQsuppressionSum[which(as.numeric(rdmDFclean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA

# for offline:
#save(rdmDFclean, file = "/Users/hayley/Desktop/RCS/data/Rdata/rdmDFall_clean.Rdata")
#save(rdmDF, file = "/Users/hayley/Desktop/RCS/data/Rdata/rdmDFall.Rdata")

# for online:
save(rdmDFclean, file = file.path(config$path$data$Rdata, 'rdmDFall_clean.Rdata'))
save(rdmDF, file = file.path(config$path$data$Rdata, 'rdmDFall.Rdata'))

```



Create subject level variables in two formats:
1) long - each participant has two rows, one for each round
2) wide - each participant has one row, all information for both rounds is in one row


From the following dataframes, we want to include:
RDMqualityCheck = subID, pgambleRound1, pgambleRound2, round1strat, round2strat, round1rt, round2rt
complexSpanCores= ospan and symspan scores
ERQscores = reappraisal and suppression scores
rdmPostRoundQsdf (each participant has a row) = difficulty, how often, condCode
postTaskNumericOnly = rdmOverallDifficulty, motivation, roundsIndependent
demographic = gender, genderCode, race, raceCode, ethnicity, ethnicityCode, age
outcomes = round 1, round 2, selected outcome, payment (1/2 of selected outcome)

```{r make-subject-level-long-dataframe}

subLevLongNames = c("subID", "pgamble", "strategy", "RTmean","RTmeanClean",  "RTmedian", "RTmedianClean", "ospan", "symspan", "compositeSpanScore", "ERQreappMean", "ERQsuppMean", "ERQreappSum", "ERQsuppSum", "instDifficult", "instHowOften", "condCode", "rdmOverallDiff", "motivation", "rdmRoundsIndep", "gender", "genderCode", "race", "raceCode", "ethnicity", "ethnicityCode", "age", "selectedOC", "rdmOCselect", "rdmOCpayment")

# for many of these variables, we will just repeat each for each participants with the exception of the variables that are unique in each round.

rcsSubLevelLong = as.data.frame(matrix(data=NA, nrow = nSub*2, ncol = length(subLevLongNames), dimnames=list(c(NULL), subLevLongNames)))
rcsSubLevelLong$subID = rep(subID, each=2)
rcsSubLevelLong$rdmOCselect = rep(rdmOutcomesClean$ocFinal, each = 2)
rcsSubLevelLong$rdmOCpayment = rep(rdmOutcomesClean$ocPayment, each = 2)
rcsSubLevelLong$age = rep(demographic$age, each = 2)
rcsSubLevelLong$gender = rep(demographic$gender, each = 2)
rcsSubLevelLong$genderCode = rep(demographic$genderCode, each = 2)
rcsSubLevelLong$race = rep(demographic$race, each = 2)
rcsSubLevelLong$raceCode = rep(demographic$raceCode, each = 2)
rcsSubLevelLong$ethnicity = rep(demographic$race, each = 2)
rcsSubLevelLong$ethnicityCode = rep(demographic$raceCode, each = 2)
rcsSubLevelLong$rdmRoundsIndep = rep(postTaskNumericOnly$roundsIndependent, each=2)
rcsSubLevelLong$motivation = rep(postTaskNumericOnly$motivation, each=2)
rcsSubLevelLong$rdmOverallDiff = rep(postTaskNumericOnly$rdmOverallDifficulty, each=2)
rcsSubLevelLong$condCode = rdmPostRoundQsdf$condCode
rcsSubLevelLong$instHowOften = rdmPostRoundQsdf$howOften
rcsSubLevelLong$instDifficult = rdmPostRoundQsdf$difficulty
rcsSubLevelLong$ERQreappSum = rep(ERQscores$reappraisalSums, each = 2)
rcsSubLevelLong$ERQsuppSum = rep(ERQscores$suppressionSums, each = 2)
rcsSubLevelLong$ERQreappMean = rep(ERQscores$reappraisalMeans, each = 2)
rcsSubLevelLong$ERQsuppMean = rep(ERQscores$suppressionMeans, each = 2)
rcsSubLevelLong$ospan = rep(complexSpanScores$ospanScore, each = 2)
rcsSubLevelLong$symspan = rep(complexSpanScores$symspanScore, each = 2)
rcsSubLevelLong$compositeSpanScore = rep(complexSpanScores$compositeSpanScore, each = 2)

# for variables that were unique in each round:
for (s in 1:nSub) {
  subInd = which(rcsSubLevelLong$subID == subID[s])
  # RT means:
  rcsSubLevelLong$RTmean[subInd[1]] = RDMqualityCheck$round1rt[s]; # RTmean all trials in round 1
  rcsSubLevelLong$RTmean[subInd[2]] = RDMqualityCheck$round2rt[s]; # RT mean all trials in round 2
  rcsSubLevelLong$RTmeanClean[subInd[1]] = mean(rdmDF$RT[as.numeric(rdmDF$subID)==s & rdmDF$roundRDM==1 & rdmDF$RT >=.5], na.rm=T); # RT mean, remove fast trials <500ms in round 1
  rcsSubLevelLong$RTmeanClean[subInd[2]] = mean(rdmDF$RT[as.numeric(rdmDF$subID)==s & rdmDF$roundRDM==2 & rdmDF$RT >=.5], na.rm=T); # RT mean, remove fast trials <500ms in round 2

  
  # RT medians:
  rcsSubLevelLong$RTmedian[subInd[1]] = median(rdmDF$RT[as.numeric(rdmDF$subID)==s & rdmDF$roundRDM==1], na.rm=T); # RT median, all trials
  rcsSubLevelLong$RTmedian[subInd[2]] = median(rdmDF$RT[as.numeric(rdmDF$subID)==s & rdmDF$roundRDM==2], na.rm=T); # RT median, all trials
  rcsSubLevelLong$RTmedianClean[subInd[1]] = median(rdmDF$RT[as.numeric(rdmDF$subID)==s & rdmDF$roundRDM==1 & rdmDF$RT >=.5], na.rm=T); # RT median with fast trials removed <500ms in round 1
  rcsSubLevelLong$RTmedianClean[subInd[2]] = median(rdmDF$RT[as.numeric(rdmDF$subID)==s & rdmDF$roundRDM==2 & rdmDF$RT >=.5], na.rm=T); # RT median with fast trials removed <500ms in round 2

  
  rcsSubLevelLong$pgamble[subInd[1]] = RDMqualityCheck$pgambleRound1[s]
  rcsSubLevelLong$pgamble[subInd[2]] = RDMqualityCheck$pgambleRound2[s]
  rcsSubLevelLong$strategy[subInd[1]] = RDMqualityCheck$round1strat[s]
  rcsSubLevelLong$strategy[subInd[2]] = RDMqualityCheck$round2strat[s]
  rcsSubLevelLong$selectedOC[subInd[1]] = rdmOutcomesClean$ocRound1[s]
  rcsSubLevelLong$selectedOC[subInd[2]] = rdmOutcomesClean$ocRound2[s]
}



```

```{r create-sub-level-wide-dataframe}
subLevWideNames = c("subID", "round1_pgamble", "round2_pgamble","round1_strategy", "round2_strategy", "round1_RTmean", "round2_RTmean", "round1_RTmeanClean", "round2_RTmeanClean", "round1_RTmedian", "round2_RTmedian","round1_RTmedianClean", "round2_RTmedianClean",  "ospan", "symspan", "compositeSpanScore", "ERQreappSum", "ERQsuppSum", "ERQreappMean", "ERQsuppMean", "round1_instDifficult","round2_instDifficult","round1_instHowOften", "round2_instHowOften", "condCode", "rdmOverallDiff", "motivation", "rdmRoundsIndep", "gender", "genderCode", "race", "raceCode", "ethnicity", "ethnicityCode", "age", "round1_oc", "round2_oc", "rdmOCselect", "rdmOCpayment")

rcsSubLevelWide = as.data.frame(matrix(data=NA, nrow = nSub, ncol = length(subLevWideNames), dimnames=list(c(NULL), subLevWideNames)))
rcsSubLevelWide$subID = subID

# variables that can just be inserted into the dataframe
rcsSubLevelWide$round1_oc = rdmOutcomesClean$ocRound1
rcsSubLevelWide$round2_oc = rdmOutcomesClean$ocRound2
rcsSubLevelWide$rdmOCselect = rdmOutcomesClean$ocFinal
rcsSubLevelWide$rdmOCpayment = rdmOutcomesClean$ocPayment
rcsSubLevelWide$age = demographic$age
rcsSubLevelWide$gender = demographic$gender
rcsSubLevelWide$genderCode = demographic$genderCode
rcsSubLevelWide$race = demographic$race
rcsSubLevelWide$raceCode = demographic$raceCode
rcsSubLevelWide$ethnicity = demographic$ethnicity
rcsSubLevelWide$ethnicityCode = demographic$ethnicityCode
rcsSubLevelWide$rdmRoundsIndep = postTaskNumericOnly$roundsIndependent
rcsSubLevelWide$motivation = postTaskNumericOnly$motivation
rcsSubLevelWide$rdmOverallDiff = postTaskNumericOnly$rdmOverallDifficulty
rcsSubLevelWide$ERQreappSum = ERQscores$reappraisalSums
rcsSubLevelWide$ERQsuppSum = ERQscores$suppressionSums
rcsSubLevelWide$ERQreappMean = ERQscores$reappraisalMeans
rcsSubLevelWide$ERQsuppMean = ERQscores$suppressionMeans
rcsSubLevelWide$ospan = complexSpanScores$ospanScore
rcsSubLevelWide$symspan = complexSpanScores$symspanScore
rcsSubLevelWide$compositeSpanScore = complexSpanScores$compositeSpanScore
rcsSubLevelWide$round1_pgamble = RDMqualityCheck$pgambleRound1
rcsSubLevelWide$round2_pgamble = RDMqualityCheck$pgambleRound2
rcsSubLevelWide$round1_RTmean = RDMqualityCheck$round1rt
rcsSubLevelWide$round2_RTmean = RDMqualityCheck$round2rt
rcsSubLevelWide$round1_strategy = RDMqualityCheck$round1strat
rcsSubLevelWide$round2_strategy = RDMqualityCheck$round2strat

# in a loop
for(s in 1:nSub){
  subData = rdmPostRoundQsdf[rdmPostRoundQsdf$subID ==subIDchr[s],]
  rcsSubLevelWide$round1_instDifficult[s] = subData$difficulty[1]
  rcsSubLevelWide$round2_instDifficult[s] = subData$difficulty[2]
  rcsSubLevelWide$round1_instHowOften[s] = subData$howOften[1]
  rcsSubLevelWide$round2_instHowOften[s] = subData$howOften[2]
  rcsSubLevelWide$condCode[s] = subData$condCode[1]
  
  rcsSubLevelWide$round1_RTmeanClean[s] = mean(rdmDF$RT[rdmDF$roundRDM==1 & as.numeric(rdmDF$subID)==s & rdmDF$RT >=.5], na.rm=T); # mean RT, remove fast trials <500ms in round 1
  rcsSubLevelWide$round2_RTmeanClean[s] = mean(rdmDF$RT[rdmDF$roundRDM==2 & as.numeric(rdmDF$subID)==s & rdmDF$RT >=.5], na.rm=T); # mean RT, remove fast trials <500ms in round 2
  
  rcsSubLevelWide$round1_RTmedian[s] = median(rdmDF$RT[rdmDF$roundRDM==1 & as.numeric(rdmDF$subID)==s], na.rm=T); # median RT, all trials
  rcsSubLevelWide$round2_RTmedian[s] = median(rdmDF$RT[rdmDF$roundRDM==2 & as.numeric(rdmDF$subID)==s], na.rm=T); # median RT, all trials
  
  rcsSubLevelWide$round1_RTmedianClean[s] = median(rdmDF$RT[rdmDF$roundRDM==1 & as.numeric(rdmDF$subID)==s & rdmDF$RT >=.5], na.rm=T); # median RT, remove fast trials <500ms in round 1
  rcsSubLevelWide$round2_RTmedianClean[s] = median(rdmDF$RT[rdmDF$roundRDM==2 & as.numeric(rdmDF$subID)==s & rdmDF$RT >=.5], na.rm=T); # median RT, remove fast trials <500 ms in round 2
}

#Apply exclusion across the board for both long and wide dataframes (save as a different version)

# RDM (remove participants excluded from RDM)
rcsSubLevelWide_clean = rcsSubLevelWide[!rcsSubLevelWide$subID %in% excludeSubID,]
rcsSubLevelLong_clean = rcsSubLevelLong[!rcsSubLevelLong$subID %in% excludeSubID,]

# put NA for missed ospan, sysmspan, ERQ
rcsSubLevelWide_clean$ospan[rcsSubLevelWide_clean$subID %in% as.numeric(ospanExclude)]=NA
rcsSubLevelWide_clean$symspan[rcsSubLevelWide_clean$subID %in% as.numeric(symspanExclude)]=NA
rcsSubLevelWide_clean$compositeSpanScore[rcsSubLevelWide_clean$subID %in% as.numeric(c(symspanExclude,ospanExclude))]=NA

rcsSubLevelWide_clean$ERQreappSum[which(as.numeric(rcsSubLevelWide_clean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rcsSubLevelWide_clean$ERQsuppSum[which(as.numeric(rcsSubLevelWide_clean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rcsSubLevelWide_clean$ERQreappMean[which(as.numeric(rcsSubLevelWide_clean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rcsSubLevelWide_clean$ERQsuppMean[which(as.numeric(rcsSubLevelWide_clean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA



rcsSubLevelLong_clean$ospan[rcsSubLevelLong_clean$subID %in% as.numeric(ospanExclude)]=NA
rcsSubLevelLong_clean$symspan[rcsSubLevelLong_clean$subID %in% as.numeric(symspanExclude)]=NA
rcsSubLevelLong_clean$compositeSpanScore[rcsSubLevelLong_clean$subID %in% as.numeric(c(symspanExclude,ospanExclude))]=NA
rcsSubLevelLong_clean$ERQreappSum[which(as.numeric(rcsSubLevelLong_clean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rcsSubLevelLong_clean$ERQsuppSum[which(as.numeric(rcsSubLevelLong_clean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rcsSubLevelLong_clean$ERQreappMean[which(as.numeric(rcsSubLevelLong_clean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA
rcsSubLevelLong_clean$ERQsuppMean[which(as.numeric(rcsSubLevelLong_clean$subID) %in% ERQexclude$subID[ERQexclude$ERQexclude==1])] = NA


```

```{r save-sub-level-dataframes}

# offline
#save(rcsSubLevelLong, file = "/Users/hayley/Desktop/RCS/data/Rdata/rcsSubLevelLong.Rdata")
#save(rcsSubLevelLong_clean, file = "/Users/hayley/Desktop/RCS/data/Rdata/rcsSubLevelLongClean.Rdata")
#save(rcsSubLevelWide, file = "/Users/hayley/Desktop/RCS/data/Rdata/rcsSubLevelWide.Rdata")
#save(rcsSubLevelWide_clean, file = "/Users/hayley/Desktop/RCS/data/Rdata/rcsSubLevelWideClean.Rdata")

# online
save(rcsSubLevelLong, file =file.path(config$path$data$Rdata, 'rcsSubLevelLong.Rdata'))
save(rcsSubLevelLong_clean, file = file.path(config$path$data$Rdata,'rcsSubLevelLongClean.Rdata'))
save(rcsSubLevelWide, file = file.path(config$path$data$Rdata, "rcsSubLevelWide.Rdata"))
save(rcsSubLevelWide_clean, file = file.path(config$path$data$Rdata,"rcsSubLevelWideClean.Rdata"))

```

